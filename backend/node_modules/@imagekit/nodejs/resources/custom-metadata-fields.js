"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomMetadataFields = void 0;
const resource_1 = require("../core/resource.js");
const path_1 = require("../internal/utils/path.js");
class CustomMetadataFields extends resource_1.APIResource {
    /**
     * This API creates a new custom metadata field. Once a custom metadata field is
     * created either through this API or using the dashboard UI, its value can be set
     * on the assets. The value of a field for an asset can be set using the media
     * library UI or programmatically through upload or update assets API.
     *
     * @example
     * ```ts
     * const customMetadataField =
     *   await client.customMetadataFields.create({
     *     label: 'price',
     *     name: 'price',
     *     schema: {
     *       type: 'Number',
     *       minValue: 1000,
     *       maxValue: 3000,
     *     },
     *   });
     * ```
     */
    create(body, options) {
        return this._client.post('/v1/customMetadataFields', { body, ...options });
    }
    /**
     * This API updates the label or schema of an existing custom metadata field.
     *
     * @example
     * ```ts
     * const customMetadataField =
     *   await client.customMetadataFields.update('id', {
     *     label: 'price',
     *     schema: {
     *       type: 'Number',
     *       minValue: 1000,
     *       maxValue: 3000,
     *     },
     *   });
     * ```
     */
    update(id, body = {}, options) {
        return this._client.patch((0, path_1.path) `/v1/customMetadataFields/${id}`, { body, ...options });
    }
    /**
     * This API returns the array of created custom metadata field objects. By default
     * the API returns only non deleted field objects, but you can include deleted
     * fields in the API response.
     *
     * You can also filter results by a specific folder path to retrieve custom
     * metadata fields applicable at that location. This path-specific filtering is
     * useful when using the **Path policy** feature to determine which custom metadata
     * fields are selected for a given path.
     *
     * @example
     * ```ts
     * const customMetadataFields =
     *   await client.customMetadataFields.list();
     * ```
     */
    list(query = {}, options) {
        return this._client.get('/v1/customMetadataFields', { query, ...options });
    }
    /**
     * This API deletes a custom metadata field. Even after deleting a custom metadata
     * field, you cannot create any new custom metadata field with the same name.
     *
     * @example
     * ```ts
     * const customMetadataField =
     *   await client.customMetadataFields.delete('id');
     * ```
     */
    delete(id, options) {
        return this._client.delete((0, path_1.path) `/v1/customMetadataFields/${id}`, options);
    }
}
exports.CustomMetadataFields = CustomMetadataFields;
//# sourceMappingURL=custom-metadata-fields.js.map