"use strict";
// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Files = void 0;
const tslib_1 = require("../../internal/tslib.js");
const resource_1 = require("../../core/resource.js");
const BulkAPI = tslib_1.__importStar(require("./bulk.js"));
const bulk_1 = require("./bulk.js");
const MetadataAPI = tslib_1.__importStar(require("./metadata.js"));
const VersionsAPI = tslib_1.__importStar(require("./versions.js"));
const versions_1 = require("./versions.js");
const headers_1 = require("../../internal/headers.js");
const uploads_1 = require("../../internal/uploads.js");
const path_1 = require("../../internal/utils/path.js");
const serialization_utils_1 = require("../../lib/serialization-utils.js");
class Files extends resource_1.APIResource {
    constructor() {
        super(...arguments);
        this.bulk = new BulkAPI.Bulk(this._client);
        this.versions = new VersionsAPI.Versions(this._client);
        this.metadata = new MetadataAPI.Metadata(this._client);
    }
    /**
     * This API updates the details or attributes of the current version of the file.
     * You can update `tags`, `customCoordinates`, `customMetadata`, publication
     * status, remove existing `AITags` and apply extensions using this API.
     *
     * @example
     * ```ts
     * const file = await client.files.update('fileId');
     * ```
     */
    update(fileID, body, options) {
        return this._client.patch((0, path_1.path) `/v1/files/${fileID}/details`, { body, ...options });
    }
    /**
     * This API deletes the file and all its file versions permanently.
     *
     * Note: If a file or specific transformation has been requested in the past, then
     * the response is cached. Deleting a file does not purge the cache. You can purge
     * the cache using purge cache API.
     *
     * @example
     * ```ts
     * await client.files.delete('fileId');
     * ```
     */
    delete(fileID, options) {
        return this._client.delete((0, path_1.path) `/v1/files/${fileID}`, {
            ...options,
            headers: (0, headers_1.buildHeaders)([{ Accept: '*/*' }, options?.headers]),
        });
    }
    /**
     * This will copy a file from one folder to another.
     *
     * Note: If any file at the destination has the same name as the source file, then
     * the source file and its versions (if `includeFileVersions` is set to true) will
     * be appended to the destination file version history.
     *
     * @example
     * ```ts
     * const response = await client.files.copy({
     *   destinationPath: '/folder/to/copy/into/',
     *   sourceFilePath: '/path/to/file.jpg',
     * });
     * ```
     */
    copy(body, options) {
        return this._client.post('/v1/files/copy', { body, ...options });
    }
    /**
     * This API returns an object with details or attributes about the current version
     * of the file.
     *
     * @example
     * ```ts
     * const file = await client.files.get('fileId');
     * ```
     */
    get(fileID, options) {
        return this._client.get((0, path_1.path) `/v1/files/${fileID}/details`, options);
    }
    /**
     * This will move a file and all its versions from one folder to another.
     *
     * Note: If any file at the destination has the same name as the source file, then
     * the source file and its versions will be appended to the destination file.
     *
     * @example
     * ```ts
     * const response = await client.files.move({
     *   destinationPath: '/folder/to/move/into/',
     *   sourceFilePath: '/path/to/file.jpg',
     * });
     * ```
     */
    move(body, options) {
        return this._client.post('/v1/files/move', { body, ...options });
    }
    /**
     * You can rename an already existing file in the media library using rename file
     * API. This operation would rename all file versions of the file.
     *
     * Note: The old URLs will stop working. The file/file version URLs cached on CDN
     * will continue to work unless a purge is requested.
     *
     * @example
     * ```ts
     * const response = await client.files.rename({
     *   filePath: '/path/to/file.jpg',
     *   newFileName: 'newFileName.jpg',
     * });
     * ```
     */
    rename(body, options) {
        return this._client.put('/v1/files/rename', { body, ...options });
    }
    /**
     * ImageKit.io allows you to upload files directly from both the server and client
     * sides. For server-side uploads, private API key authentication is used. For
     * client-side uploads, generate a one-time `token`, `signature`, and `expire` from
     * your secure backend using private API.
     * [Learn more](/docs/api-reference/upload-file/upload-file#how-to-implement-client-side-file-upload)
     * about how to implement client-side file upload.
     *
     * The [V2 API](/docs/api-reference/upload-file/upload-file-v2) enhances security
     * by verifying the entire payload using JWT.
     *
     * **File size limit** \
     * On the free plan, the maximum upload file sizes are 20MB for images, audio, and raw
     * files and 100MB for videos. On the paid plan, these limits increase to 40MB for images,
     * audio, and raw files and 2GB for videos. These limits can be further increased with
     * higher-tier plans.
     *
     * **Version limit** \
     * A file can have a maximum of 100 versions.
     *
     * **Demo applications**
     *
     * - A full-fledged
     *   [upload widget using Uppy](https://github.com/imagekit-samples/uppy-uploader),
     *   supporting file selections from local storage, URL, Dropbox, Google Drive,
     *   Instagram, and more.
     * - [Quick start guides](/docs/quick-start-guides) for various frameworks and
     *   technologies.
     *
     * @example
     * ```ts
     * const response = await client.files.upload({
     *   file: fs.createReadStream('path/to/file'),
     *   fileName: 'fileName',
     * });
     * ```
     */
    upload(body, options) {
        const serializedBody = (0, serialization_utils_1.serializeUploadOptions)(body);
        return this._client.post('/api/v1/files/upload', (0, uploads_1.multipartFormRequestOptions)({ body: serializedBody, defaultBaseURL: 'https://upload.imagekit.io', ...options }, this._client));
    }
}
exports.Files = Files;
Files.Bulk = bulk_1.Bulk;
Files.Versions = versions_1.Versions;
//# sourceMappingURL=files.js.map