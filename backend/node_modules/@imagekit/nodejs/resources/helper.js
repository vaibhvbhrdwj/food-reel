"use strict";
// Helper resource for additional utility functions
// File manually created for helper functions - not generated
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helper = void 0;
const tslib_1 = require("../internal/tslib.js");
const resource_1 = require("../core/resource.js");
const transformation_utils_1 = tslib_1.__importStar(require("../lib/transformation-utils.js"));
const crypto_utils_1 = require("../lib/crypto-utils.js");
const uuid_1 = require("../internal/utils/uuid.js");
const TRANSFORMATION_PARAMETER = 'tr';
const SIGNATURE_PARAMETER = 'ik-s';
const TIMESTAMP_PARAMETER = 'ik-t';
const DEFAULT_TIMESTAMP = 9999999999;
const SIMPLE_OVERLAY_PATH_REGEX = new RegExp('^[a-zA-Z0-9-._/ ]*$');
const SIMPLE_OVERLAY_TEXT_REGEX = new RegExp('^[a-zA-Z0-9-._ ]*$');
class Helper extends resource_1.APIResource {
    constructor(client) {
        super(client);
    }
    /**
     * Builds a source URL with the given options.
     *
     * @param opts - The options for building the source URL.
     * @returns The constructed source URL.
     */
    buildSrc(opts) {
        opts.urlEndpoint = opts.urlEndpoint || '';
        opts.src = opts.src || '';
        opts.transformationPosition = opts.transformationPosition || 'query';
        if (!opts.src) {
            return '';
        }
        const isAbsoluteURL = opts.src.startsWith('http://') || opts.src.startsWith('https://');
        var urlObj, isSrcParameterUsedForURL, urlEndpointPattern;
        try {
            if (!isAbsoluteURL) {
                urlEndpointPattern = new URL(opts.urlEndpoint).pathname;
                urlObj = new URL(pathJoin([opts.urlEndpoint.replace(urlEndpointPattern, ''), opts.src]));
            }
            else {
                urlObj = new URL(opts.src);
                isSrcParameterUsedForURL = true;
            }
        }
        catch (e) {
            return '';
        }
        for (var i in opts.queryParameters) {
            urlObj.searchParams.append(i, String(opts.queryParameters[i]));
        }
        var transformationString = this.buildTransformationString(opts.transformation);
        if (transformationString && transformationString.length) {
            if (!transformation_utils_1.default.addAsQueryParameter(opts) && !isSrcParameterUsedForURL) {
                urlObj.pathname = pathJoin([
                    TRANSFORMATION_PARAMETER + transformation_utils_1.default.getChainTransformDelimiter() + transformationString,
                    urlObj.pathname,
                ]);
            }
        }
        if (urlEndpointPattern) {
            urlObj.pathname = pathJoin([urlEndpointPattern, urlObj.pathname]);
        }
        else {
            urlObj.pathname = pathJoin([urlObj.pathname]);
        }
        // First, build the complete URL with transformations
        let finalUrl = urlObj.href;
        // Add transformation parameter manually to avoid URL encoding
        // URLSearchParams.set() would encode commas and colons in transformation string,
        // It would work correctly but not very readable e.g., "w-300,h-400" is better than "w-300%2Ch-400"
        if (transformationString && transformationString.length) {
            if (transformation_utils_1.default.addAsQueryParameter(opts) || isSrcParameterUsedForURL) {
                const separator = urlObj.searchParams.toString() ? '&' : '?';
                finalUrl = `${finalUrl}${separator}${TRANSFORMATION_PARAMETER}=${transformationString}`;
            }
        }
        // Then sign the URL if needed
        if (opts.signed === true || (opts.expiresIn && opts.expiresIn > 0)) {
            const expiryTimestamp = getSignatureTimestamp(opts.expiresIn);
            const urlSignature = getSignature({
                privateKey: this._client.privateKey,
                url: finalUrl,
                urlEndpoint: opts.urlEndpoint,
                expiryTimestamp,
            });
            // Add signature parameters to the final URL
            // Use URL object to properly determine if we need ? or & separator
            const finalUrlObj = new URL(finalUrl);
            const hasExistingParams = finalUrlObj.searchParams.toString().length > 0;
            const separator = hasExistingParams ? '&' : '?';
            let signedUrl = finalUrl;
            if (expiryTimestamp && expiryTimestamp !== DEFAULT_TIMESTAMP) {
                signedUrl += `${separator}${TIMESTAMP_PARAMETER}=${expiryTimestamp}`;
                signedUrl += `&${SIGNATURE_PARAMETER}=${urlSignature}`;
            }
            else {
                signedUrl += `${separator}${SIGNATURE_PARAMETER}=${urlSignature}`;
            }
            return signedUrl;
        }
        return finalUrl;
    }
    /**
     * Builds a transformation string from the given transformations.
     *
     * @param transformation - The transformations to apply.
     * @returns The constructed transformation string.
     */
    buildTransformationString(transformation) {
        return buildTransformationString(transformation);
    }
    /**
     * Generates authentication parameters for client-side file uploads using ImageKit's Upload API V1.
     *
     * This method creates the required authentication signature that allows secure file uploads
     * directly from the browser or mobile applications without exposing your private API key.
     * The generated parameters include a unique token, expiration timestamp, and HMAC signature.
     *
     * @param token - Custom token for the upload session. If not provided, a UUID v4 will be generated automatically.
     * @param expire - Expiration time in seconds from now. If not provided, defaults to 1800 seconds (30 minutes).
     * @returns Authentication parameters object containing:
     *   - `token`: Unique identifier for this upload session
     *   - `expire`: Unix timestamp when these parameters expire
     *   - `signature`: HMAC-SHA1 signature for authenticating the upload
     *
     * @throws {Error} If the private API key is not configured (should not happen in normal usage)
     */
    getAuthenticationParameters(token, expire) {
        if (!this._client.privateKey) {
            throw new Error('Private API key is required for authentication parameters generation');
        }
        const DEFAULT_TIME_DIFF = 60 * 30;
        const defaultExpire = Math.floor(Date.now() / 1000) + DEFAULT_TIME_DIFF;
        const finalToken = token || (0, uuid_1.uuid4)();
        const finalExpire = expire || defaultExpire;
        return getAuthenticationParameters(finalToken, finalExpire, this._client.privateKey);
    }
}
exports.Helper = Helper;
const getAuthenticationParameters = function (token, expire, privateKey) {
    var authParameters = {
        token: token,
        expire: expire,
        signature: '',
    };
    var signature = (0, crypto_utils_1.createHmacSha1)(privateKey, token + expire);
    authParameters.signature = signature;
    return authParameters;
};
function removeTrailingSlash(str) {
    if (typeof str == 'string' && str[str.length - 1] == '/') {
        str = str.substring(0, str.length - 1);
    }
    return str;
}
function removeLeadingSlash(str) {
    if (typeof str == 'string' && str[0] == '/') {
        str = str.slice(1);
    }
    return str;
}
function pathJoin(parts, sep) {
    var separator = sep || '/';
    var replace = new RegExp(separator + '{1,}', 'g');
    return parts.join(separator).replace(replace, separator);
}
function processInputPath(str, encoding) {
    // Remove leading and trailing slashes
    str = removeTrailingSlash(removeLeadingSlash(str));
    if (encoding === 'plain') {
        return `i-${str.replace(/\//g, '@@')}`;
    }
    if (encoding === 'base64') {
        return `ie-${encodeURIComponent((0, transformation_utils_1.safeBtoa)(str))}`;
    }
    if (SIMPLE_OVERLAY_PATH_REGEX.test(str)) {
        return `i-${str.replace(/\//g, '@@')}`;
    }
    else {
        return `ie-${encodeURIComponent((0, transformation_utils_1.safeBtoa)(str))}`;
    }
}
function processText(str, encoding) {
    if (encoding === 'plain') {
        return `i-${encodeURIComponent(str)}`;
    }
    if (encoding === 'base64') {
        return `ie-${encodeURIComponent((0, transformation_utils_1.safeBtoa)(str))}`;
    }
    if (SIMPLE_OVERLAY_TEXT_REGEX.test(str)) {
        return `i-${encodeURIComponent(str)}`;
    }
    return `ie-${encodeURIComponent((0, transformation_utils_1.safeBtoa)(str))}`;
}
function processOverlay(overlay) {
    const entries = [];
    const { type, position = {}, timing = {}, transformation = [] } = overlay || {};
    if (!type) {
        return;
    }
    switch (type) {
        case 'text':
            {
                const textOverlay = overlay;
                if (!textOverlay.text) {
                    return;
                }
                const encoding = textOverlay.encoding || 'auto';
                entries.push('l-text');
                entries.push(processText(textOverlay.text, encoding));
            }
            break;
        case 'image':
            entries.push('l-image');
            {
                const imageOverlay = overlay;
                const encoding = imageOverlay.encoding || 'auto';
                if (imageOverlay.input) {
                    entries.push(processInputPath(imageOverlay.input, encoding));
                }
                else {
                    return;
                }
            }
            break;
        case 'video':
            entries.push('l-video');
            {
                const videoOverlay = overlay;
                const encoding = videoOverlay.encoding || 'auto';
                if (videoOverlay.input) {
                    entries.push(processInputPath(videoOverlay.input, encoding));
                }
                else {
                    return;
                }
            }
            break;
        case 'subtitle':
            entries.push('l-subtitle');
            {
                const subtitleOverlay = overlay;
                const encoding = subtitleOverlay.encoding || 'auto';
                if (subtitleOverlay.input) {
                    entries.push(processInputPath(subtitleOverlay.input, encoding));
                }
                else {
                    return;
                }
            }
            break;
        case 'solidColor':
            entries.push('l-image');
            entries.push(`i-ik_canvas`);
            {
                const solidColorOverlay = overlay;
                if (solidColorOverlay.color) {
                    entries.push(`bg-${solidColorOverlay.color}`);
                }
                else {
                    return;
                }
            }
            break;
    }
    const { x, y, focus } = position;
    if (x) {
        entries.push(`lx-${x}`);
    }
    if (y) {
        entries.push(`ly-${y}`);
    }
    if (focus) {
        entries.push(`lfo-${focus}`);
    }
    const { start, end, duration } = timing;
    if (start) {
        entries.push(`lso-${start}`);
    }
    if (end) {
        entries.push(`leo-${end}`);
    }
    if (duration) {
        entries.push(`ldu-${duration}`);
    }
    const transformationString = buildTransformationString(transformation);
    if (transformationString && transformationString.trim() !== '') {
        entries.push(transformationString);
    }
    entries.push('l-end');
    return entries.join(transformation_utils_1.default.getTransformDelimiter());
}
function buildTransformationString(transformation) {
    if (!Array.isArray(transformation)) {
        return '';
    }
    var parsedTransforms = [];
    for (var i = 0, l = transformation.length; i < l; i++) {
        var parsedTransformStep = [];
        const currentTransform = transformation[i];
        if (!currentTransform)
            continue;
        for (var key in currentTransform) {
            let value = currentTransform[key];
            if (value === undefined || value === null) {
                continue;
            }
            if (key === 'overlay' && typeof value === 'object') {
                var rawString = processOverlay(value);
                if (rawString && rawString.trim() !== '') {
                    parsedTransformStep.push(rawString);
                }
                continue; // Always continue as overlay is processed.
            }
            var transformKey = transformation_utils_1.default.getTransformKey(key);
            if (!transformKey) {
                transformKey = key;
            }
            if (transformKey === '') {
                continue;
            }
            if ([
                'e-grayscale',
                'e-contrast',
                'e-removedotbg',
                'e-bgremove',
                'e-upscale',
                'e-retouch',
                'e-genvar',
            ].includes(transformKey)) {
                if (value === true || value === '-' || value === 'true') {
                    parsedTransformStep.push(transformKey);
                }
                else {
                    // Any other value means that the effect should not be applied
                    continue;
                }
            }
            else if (['e-sharpen', 'e-shadow', 'e-gradient', 'e-usm', 'e-dropshadow'].includes(transformKey) &&
                (value.toString().trim() === '' || value === true || value === 'true')) {
                parsedTransformStep.push(transformKey);
            }
            else if (key === 'raw') {
                parsedTransformStep.push(currentTransform[key]);
            }
            else {
                if (transformKey === 'di' || transformKey === 'ff') {
                    value = removeTrailingSlash(removeLeadingSlash(value || ''));
                    value = value.replace(/\//g, '@@');
                }
                if (transformKey === 'sr' && Array.isArray(value)) {
                    value = value.join('_');
                }
                // Special case for trim with empty string - should be treated as true
                if (transformKey === 't' && value.toString().trim() === '') {
                    value = 'true';
                }
                parsedTransformStep.push([transformKey, value].join(transformation_utils_1.default.getTransformKeyValueDelimiter()));
            }
        }
        if (parsedTransformStep.length) {
            parsedTransforms.push(parsedTransformStep.join(transformation_utils_1.default.getTransformDelimiter()));
        }
    }
    return parsedTransforms.join(transformation_utils_1.default.getChainTransformDelimiter());
}
/**
 * Calculates the expiry timestamp for URL signing
 *
 * @param seconds - Number of seconds from now when the URL should expire
 * @returns Unix timestamp for expiry, or DEFAULT_TIMESTAMP if invalid/not provided
 */
function getSignatureTimestamp(seconds) {
    if (!seconds || seconds <= 0)
        return DEFAULT_TIMESTAMP;
    const sec = parseInt(String(seconds), 10);
    if (!sec || isNaN(sec))
        return DEFAULT_TIMESTAMP;
    const currentTimestamp = Math.floor(new Date().getTime() / 1000);
    return currentTimestamp + sec;
}
/**
 * Generates an HMAC-SHA1 signature for URL signing
 *
 * @param opts - Options containing private key, URL, endpoint, and expiry timestamp
 * @returns Hex-encoded signature, or empty string if required params missing
 */
function getSignature(opts) {
    if (!opts.privateKey || !opts.url || !opts.urlEndpoint)
        return '';
    // Create the string to sign: relative path + expiry timestamp
    const stringToSign = opts.url.replace(addTrailingSlash(opts.urlEndpoint), '') + String(opts.expiryTimestamp);
    return (0, crypto_utils_1.createHmacSha1)(opts.privateKey, stringToSign);
}
function addTrailingSlash(str) {
    if (typeof str === 'string' && str[str.length - 1] !== '/') {
        str = str + '/';
    }
    return str;
}
//# sourceMappingURL=helper.js.map